const exampleSeperator = "======================================================="
//Μπορώ είτε να βάλω είτε να μη βάλω semicolon, ο κώδικας θα
//δουλέψει σωστά.
//Υπάρχει ένα debate μεταξύ των εταιρειών και
//των προγραμματιστών για το αν είναι ωραιότερο να βάζεις
//ή να μην βάζεις. Το σίγουρο είναι πως ότι αποφασίσεις
//καλό είναι να το τηρήσεις σε όλο τον κώδικα.
//Αν όμως γράψω δύο διαφορετικές εντολές σε μία γραμμή
//τότε αναγκαστικά πρέπει να τις χωρίσω μεταξύ τους με
//semicolon.

console.log(true);
console.log(typeof true);

console.log("nickie");
console.log(typeof "nickie");

console.log(undefined, null);
console.log(typeof undefined, typeof null);

//Πρώτο "περίεργο" της Javascript.
//Γιατί υπάρχει και το undefined και το null?
//Στο ακόλουθο παράδειγμα θα τυπώσει undefined.
//Το undefined λοιπόν είναι η τιμή που έχουν όλα
//τα πράγματα που δεν είναι αρχικοποιημένα, που δεν
//τα έχουμε ορίσει ακόμα.

let x;

console.log(x);

x = 42;

console.log(x);

//Το null είναι διαφορετικό του undefined. Το null
//σημαίνει ότι είναι ορισμένο ένα πράγμα, μία μεταβλητή
//έχει μία τιμή, αλλά αυτή η τιμή είναι null, είναι 
//δηλαδή μία τιμή η οποία σημαίνει ότι δεν θέλαμε να βάλουμε
//κάτι εκεί πέρα (πχ χρησιμοποιείται σε δέντρα για "άδειους" κόμβους).
//Ίσως δεν είναι η καλύτερη εξήγηση αλλά σκεφτείτε το ως μία
//τιμή που είναι ορισμένη, αλλά απροσδιόριστη/άδεια, ενώ
//το undefined δείχνει ανυπαρξία τιμής. 

console.log(exampleSeperator);
//==================================================================================================================================

//ύψωση σε δύναμη
console.log(2**20);
console.log(2**54);

//BigInts: γράφονται με ένα n δίπλα στον αριθμό.
//Όταν χρησιμοποιούμε BigInts πρέπει όλοι οι αριμθοί
//στην έκφραση να είναι BigInts, δηλαδή δεν μπορείς να
//συνδυάζεις BigInts με απλούς αριθμούς στην ίδια έκφραση.

console.log(2n**54n);

//Τί θα γίνει αν δοκιμάσω το 2 εις την 55?
//Παρατηρώ ότι σαν απλό number έχει κάποιο πρόβλημα,
//τελειώνει σε 0  πράγμα αδύνατον αφού είναι δυναμή του 2
//άρα αυτό μας λέει ότι το 2 εις την 55 έχει χάσει σε ακρίβεια
//(αφού τα numbers ουσιαστικά είναι floating point)
//Με BigInts υπολογίζεται σωστά (O! Thavma).

console.log(2**55);
console.log(2n**55n);

//Για πολύ μεγάλους αριθμούς, με BigInts θα έχω κανονικά
//τον αριθμό ενώ με απλά numbers θα μου δώσει infinity
//(for dummmies άπειρο στα εγγλέζικα)
//σύμφωνα με το ΙΕΕΕ που μου δίνει τιμές για +-άπειρο.

console.log(2n**2000n);
console.log(2**2000);

console.log(exampleSeperator)

//==================================================================================================================================

//Tα strings είναι immutable (όχι αυτά τα strings).
//Αν προσπαθήσω να αλλάξω κάποιο χαρακτήρα, η Javascript
//απλώς θα αγνοήσει την ανάθεση.
//(δεν θα γίνει τίποτα, ούτε θα πετάξει error).
let s = "nickie"

console.log(s[3]);
s[3] = 'x';
console.log(s);
console.log(s[3]);

//Έτσι αν θες να αλλάξεις ένα string, το καλύτερο που
//έχεις να κάνεις είναι απλώς να αναθέσεις μία νέα τιμή στη μεταβλητή
//πχ s = nixkie. Υπάρχουν fancy τρόποι για να "αλλάξουμε" το 
//χαρακτήρα σε συγκεκριμένο index, αλλά προσωπικά
//δεν το έχω χρειαστεί ποτέ.

//Πράξεις με συμβολοσειρές
//Συνένωση συμβολοσειρών
console.log("nick" + 'ie');

//αν προσπαθήσω να προσθέσω μία συμβολοσειρά με
//ο,τιδήποτε δεν είναι συμβολοσειρά, θα προσπαθήσει
//να μετατρέψει αυτό το πράγμα σε συμβολοσειρά

console.log("nickie" + 42);

console.log("nickie" + null)

//αν προσπαθήσω να κάνω μία πράξη που δεν ορίζεται για strings
//πχ αφαίρεση ή πολλαπλασιασμό, θα μου πει ότι το
//αποτέλεσμα είναι NaN (Not a Number) το οποίο σημαίνει
//ότι έχεις κάνει κάποιο λάθος τύπων σε κάποια αριθμητική πράξη
//ή ότι έχεις κάνει κάτι που δεν ορίζεται
//(Φυσικά ο έλεγχος τύπου και άρα το σφάλμα θα γίνει στο runtime
//αφού η Javascript έχει δυναμικούς τύπους.
//Ελπίζω κάπου εδώ να γίνεται ξεκάθαρο το γιατί δημιουργήθηκε η Typescript...)

console.log("nickie" - 42);

console.log(exampleSeperator)

//==================================================================================================================================

//Δεύτερο "περίεργο" της Javascript
//Έχουμε όχι μόνο τους διπλούς που γνωρίζατε ως τώρα
//αλλά και τους τριπλούς τελεστές ισότητας.
//Η διαφορά ευτυχώς είναι αρκετά ξεκάθαρη.
//==, != συγκρίνουν ΜΟΝΟ την τιμή
//===, !== συγκρίνουν ΟΧΙ ΜΟΝΟ την τιμή, αλλά ΚΑΙ τον τύπο

//false
console.log(null == "null")
//false
console.log(0 == "null")
//true
console.log(0 == "0")
//true
console.log(0n == "0")
//false
console.log(0 === "0")
//false
console.log(0 === 0n)

console.log(exampleSeperator)

//==================================================================================================================================

//Τρίτο "περίεργο" της Javascript
//Template literals
//Από τα πιο χρήσιμα "περίεργα" της Javascript.
//Είναι συμβολοσειρές που περικλείονται όχι σε διπλά εισαγωγικά
//αλλά σε backtick (`). Έχουν δύο ενδιαφέροντα χαρακτηριστικά

//1) μπορείς να "καρφώσεις" (όχι αυτό που σκεφτήκατε, να κάνεις embed εννοώ)
//μία συγκεκριμένη έκφραση η οποία αποτιμάται και αντικαθίσταται
//από την τιμή της, δηλαδή στην παρακάτω έκφραση:

let z = 6, y = z+1
let str = `${z} times ${y} = ${z*y}`
console.log(str)

//Στο σημείο ${z} θα υπολογιστεί το z, που έχει την τιμή 6
//και το αποτέλεσμα θα αντικαταστήσει το ${z}
//Το ίδιο θα συμβεί και για το ${y} το οποίο θα πάρει την τιμή
//7, ενώ το ${z*y} θα πάρει την τιμή 6*7 = 42.

//2) μπορείς να σπάσεις τα template literals σε περισσότερες
//γραμμές και σε αυτή την περίπτωση η JavaScript πάει και βάζει
//τα new lines ανάμεσα (O! Thavma δεύτερος τόμος)

let m = `Hello
world`

//θα δώσει true
console.log(m === "Hello\nworld");

//Tα templates είναι πολύ βολικά γιατί μας επιτρέπουν να φτιάχνουμε tag templates, όπως το παρακάτω που έχει tag html
// html`<p class="${c}">${txt}</p>`
//Στην πραγματικότητα αυτό που κάνει αυτό εδώ ειναι να καλεί μία συνάρτηση που ονομάζεται όπως το tag και να της δίνει
//το template αλλά κομμένο σε κομματάκια, το οποίο σημαίνει ότι αν εσύ έχεις γράψει κατάλληλα τη συνάρτηση, μπορείς εδώ να κάνεις την
//επεξαργασία της συμβολοσειράς και να πάρεις σαν αποτέλεσμα ένα αντικείμενο το οποίο να σου δίνει τη δομή που έχει αυτό εδώ

console.log(exampleSeperator)

//==================================================================================================================================

//Regular expressions
//(ξέρω ότι τις μισείτε)
//τις αναπαριστούμε μέσα σε καθέτους / /

//το παρακάτω λέει ότι ξεκινάει με i, τελειώνει με i και ανάμεσα έχει οσουσδήποτε χαρακτήρες
let re = /i.*i/
let st = "nickie"

//το test θα γυρίσει true γιατί μας λέει αν το regular expression
//μπορεί να βρεθεί μέσα στο st
re.test(st)

//To exec μας γυρνάει ένα αποτέλεσμα που μας λέει που ακριβώς μέσα στο 
//string βρίσκεται το regular expression.
re.exec(st)

console.log(/i.*i/.exec("nickie"))

//ακριβώς το ίδιο κάνει και το match
console.log(st.match(re))

//το search μας δείχνει το index στο οποίο βρίσκεται η αντιστοίχιση με τη regular expression
console.log(st.search(re))

//το replace αντικαθιστά ό,τι υπάρχει στο σημείο που αντιστοιχεί με τη regular expression, με κάτι άλλο
console.log(st.replace(re, "LOL"))

//Το split σπάει μία συμολοσειρά σε κάποιο συγκεκριμένο regular expression
console.log(st.split(re))

console.log(exampleSeperator)

//==================================================================================================================================

//Tέταρτο "περίεργο" της Javascript
//Ίσως από τα χειρότερα...
//Hoisting:
//Η εμβέλεια της μεταβλητής "ανεβαίνει", δηλαδή εδώ το var είναι σαν να ορίζεται στην αρχή του function ακόμα και αν
//το ορίσω μέσα στο if. Οι αναθέσεις όμως μένουν από το σημείο που τις δίνουμε και μετά, γιαυτό το πρώτο log
//θα τυπώσει undefined
function fu() {
    console.log(thenumber);
    if (true) {
        var thenumber = 42;
        console.log(thenumber);
    }
    console.log(thenumber);
}

fu()

//το πρόβλημα διορθώνεται με τη χρήση της λέξης let, η οποία καθορίζει τις εμβέλειες όπως τις έχουμε συνηθίσει:
function g() {
    let x = 17;
    if (true) {
        let x = 42;
        console.log(x);
    }
    console.log(x);
}

g()

//αν και τα δυο let τα κάνω var, θα τυπωθεί 2 φορές το 42:

function h() {
    var x = 17;
    if (true) {
        var x = 42;
        console.log(x);
    }
    console.log(x);
}

h()

//Προσωπικά δεν έχω δει κανέναν να χρησιμοποιεί το var, ούτε έχω βρει κάποια χρησιμότητα για τις
//περίεργες εμβέλειες που φτιάχνει. Το καλύτερο είναι να μην χρησιμοποείτε ποτέ var, μόνο let
//ή const (φυσικά η const λειτουργεί όπως στις άλλες γλώσσες προγραμματισμού, ας πούμε λειτουργεί
//ακριβώς όπως στη Java, το οποίο σημαίνει ότι δεν μπορούμε να κάνουμε reassign μία const μεταβλητή,
//μπορούμε όμως να αλλάξουμε επί μέρους πεδία αν στην μεταβλητή έχει ανατεθεί κάποιο object)

//==================================================================================================================================

//loops
//break και continue
//έστω ότι θέλω να βγω από το εξωτερικό for (και όχι μόνο από το εσωτερικό)
//Στη C++ δεν μπορούμε να το κάνουμε αυτό, χρειαζόμαστε boolean variables
//Στη JavaScript όπως και στη Java μπορούμε να βάζουμε labels στις
//λούπες και να κάνουμε break ή continue σε συγκεκριμένη λούπα
OUTER:
for (let i = 0; i < 10; i++)
    for (let j = 0; j < i; j++)
        if (true)
            break OUTER;

//Το for με in διατρέχει όλες τις αριθμήσιμες ιδιότητες ενός αντικειμένου
//το p κάθε φορά θα είναι το όνομα της ιδιότητας που βρέθηκε μέσα στο αντικείμενο
let obj = {
            name: "nickie",
            phone: 3393
            };
for (const p in obj)
    console.log(p + ': ' + obj[p]);

//Το for με of λειτουργεί αρκετά διαφορετικά. Διατρέχει
//ένα iterable object (πχ array). Tο x κάθε φορά θα είναι το επόμενο αντικείμενο
//που βρίσκεται στη συλλογή
let arr = [17, 42, "nickie"];
for (const x of arr)
    console.log(x);

console.log(exampleSeperator)
//==================================================================================================================================

//Οι συναρτήσεις μπορούν να οριστούν είτε σαν δήλωση...
function f(x) {
    return x * (x+1);
}

//...είτε σαν έκφραση (μας θυμίζει τις λ-εκφράσεις της ML, και
//το αποτέλεσμα, που είναι αυτή η ανώνυμη συνάρτηση, το βάζουμε στη μεταβλητή k)
const k = function(x) {
    return x * (x+1);
}

//αν θέλουμε να ορίσουμε μία αναδρομική συνάρτηση με αυτόν
//τον τρόπο, μπορούμε να το κάνουμε βάζοντας κι ένα όνομα στο function, πχ f:
const factorial = function f(n) {
    return n < 2 ? 1 : n * f(n-1);
}

//Υπάρχουν επίσης τα arrow functions, τα οποία μας θυμίζουν ακόμα περισσότερο
//τις λ-εκφράσεις της ML. H συνάρτηση f παίρνει το x σαν παράμετρο και επιστρέφει
//εκτελώντας το σώμα που βρίσκεται μέσα στις αγκύλες (μπορούμε να βάλουμε όσες εντολές θέλουμε) 
const l = x => {
    return x * (x+1);
}

//Τα arrow functions μπορούν να απλοποιηθούν ακόμα περισσότερο:
//Αν το σώμα κάνει απλώς ένα return, μπορούμε να μη γράψουμε τα άγκιστρα
//και το return, αλλά να γράψουμε κατευθείαν το παρακάτω:
const o = x => x * (x+1);

//Η παρακάτω συνάρτηση παίρνει δύο παραμέτρους x και s:
const add = (s, x) => s + x;

//ενώ αυτή η συνάρτηση δεν παίρνει καμία παράμετρο:
const c = () => 42;

//σαν τη map της ML
[1, 2, 3, 4].map(x => 2*x);

//σαν τη fold της ML
[1, 2, 3, 4].reduce(add);

//High order function: μία συνάρτηση η οποία επιστρέφει ως αποτέλεσμα μία άλλη
//συνάρτηση (εδώ η increaseBy επιστρέφει ως αποτέλεσμα τη συνάρτηση result)
function increaseBy(x) {
    function result(y) {
        return x + y;
    }  return result;
}

//καλώντας την increaseBy με το 3, αυτή θα μου δώσει πίσω μία συνάρτηση f, η οποία
//κάθε φορά που θα καλείται θα προσθέτει το 3 στην παράμετρό της
const q = increaseBy(3);
const a = f(5);
//το παραπάνω μπορεί να γίνει και σε ένα βήμα (currying):
const b = increaseBy(3)(5);

//Βλέπουμε λοιπόν ότι η JavaScript έχει διάφορα κόλπα που συναντήσαμε στο συναρτησιακό
//προγραμματισμό, όπως στην ML. Όπως και αν σας έχει φανεί ο συναρτησιακός 
//προγραμματισμός μέχρι τώρα, γράφοντας JavaScript θα δείτε ότι το συναρτησιακό
//στυλ βοηθάει σε πολλές περιπτώσεις να γράψουμε τα πράγματα πιο κομψά και πιο γρήγορα.

//παράμετροι συνάρτησης
function parametersExample(x, y, z) {
    console.log(x, y, z);
}

parametersExample(1, 2, 3);

//και κάπου εδώ, μιας κι αργήσαμε, έρχεται το...
//Πέμπτο "περίεργο" της Javascript
//Aν δώσω περισσότερες παραμέτρους από αυτές που περιμένει η συνάρτηση, τότε πετάει
//(αγνοεί) τις παραμέτρους που περισσεύουν και κρατάει όσες της χρειάζονται από τον ορισμό της.
//Το πρόγραμμα δεν πρόκειται να εμφανίσει error, ούτε καν warning, απλώς όλες οι 
//περιττές παράμετροι θα αγνοηθούν εντελώς. That's JavaScript for you!
//Στο ακόλουθο παράδειγμα, η συνάρτηση, αφού από τον ορισμό της δέχεται κανονικά 3 παραμέτρους,
//θα πάρει τις 3 πρώτες παραμέτρους που δώσαμε και θα αγνοήσει εντελώς την τέταρτη.
parametersExample(1, 2, 3, 4);

//Αντίθετα, αν δώσω λιγότερες παραμέτρους, όσες παραμέτρους δεν έδωσα θα γίνουν undefined.
//Και ναι, όπως ίσως καλά μαντέψατε, το πρόγραμμα δεν πρόκειται να εμφανίσει error, ούτε καν warning,
//απλώς όλες οι παράμετροι που δεν δόθηκαν θα γίνουν undefined. Αν θες να βλέπεις errors γράψε
//TypeScript, ή κάτι που δεν έχει το Script μέσα στο ονομά του τέλος πάντων, εδώ γράφουμε JavaScript
//και χεστήκαμε για κάθε είδους προστασία προς τον προγραμματιστή.
//Υποθέτοντας ότι προέρχεστε από φυσιολογικές γλώσσες κι όχι από κάτι σαν τη JavaScript, κάτι τέτοιο
//εκ πρώτης όψεως μοιάζει τουλάχιστον παράλογο, αν όχι ηλίθιο. Είναι όμως ένας 
//μηχανισμός ιδιαιτέρως χρήσιμος αν θέλετε να έχετε προαιρετικές παραμέτρους, 
//ή παραμέτρους που η τιμή τους δεν έχει οριστεί ακόμα, και ίσως να οριστεί
//στο μέλλον (κρατήστε το μέλλον για όταν φτάσουμε στα promises και τα async functions)
//(θα δείτε κι άλλα τέτοια εκ πρώτης όψεως παράξενα στην JavaScript. Ύστερα από αυτό
//ίσως αρχίσει να γίνεται σαφές το γιατί στη γλώσσα υπάρχει και το undefined και το null)

parametersExample(1, 2);
parametersExample(1);
parametersExample();

//Μπορώ επίσης να δώσω default τιμές στις παραμέτρους ακριβώς όπως στη C++ (και σε πολλές
//άλλες γλώσσες φυσικά)
//Αυτό μπορώ να το κάνω και για arrow functions και για κανονικές συναρτήσεις
function defaultValues(x = 42, y = 17) {
    console.log(x, y);
}

defaultValues()
defaultValues(3)
defaultValues(67,68)

const d = (x, y = 17) => {
    console.log(x, y);
}

d()
d(4)
d(6,7)

//ένα άλλο κόλπο, που υπάρχει και στην python είναι η χρήση
//του πίνακα παραμέτρων rest. Ο πίνακας rest θα περιέχει τις υπόλοιπες/παραπανήσιες
//παραμέτρους που δίνονται, οι οποίες δεν έχουν γραφεί ρητά στον ορισμό της συνάρτησης:
function checkrest(x, y, ...rest) {
    console.log(x, y, rest);
}

checkrest(1, 2, 3, 4);  // x = 1, y = 2, rest = [3, 4]
//αν δεν υπάρχουν αρκετές παράμετροι, το rest θα είναι το κενό array
checkrest(1, 2); //  x = 1, y = 2, rest = []
checkrest(1); //  x = 1, y = undefined, rest = []
checkrest(); // x = undefined, y = undefined, rest = []

console.log(exampleSeperator)

//==================================================================================================================================

//objects
//Τα objects στη JavaScript, τουλάχιστον κατά τη γνώμη μου, είναι πολύ ωραία
//και ευέλικτα. Ουσιαστικά αποτελούν συλλογές από properties. Οι properties
//με τη σειρά τους είναι απλώς key-value pairs, όπου key το όνομα της ιδιότητας
//και value η τιμή της. Ως value μπορούμε να έχουμε ο,τιδήποτε, ακόμη και άλλο
//object ή συνάρτηση. Αν έχουμε συνάρτηση τότε η property καλείται method, 
//όπως έχουμε συνηθίσει από της αντικειμενοστρεφείς γλώσσες προγραμματισμού.

//Το object περικλείεται σε {}, μέσα στα οποία βρίσκονται τα key-value pairs
//Το παρακάτω αποτελεί το κενό object.
let obje = {}
//προσπαθώντας να αναθέσω μία property του object η οποία δεν υπάρχει στο 
//object, την δημιουργώ, επεκτείνοντας έτσι το object.
obje.name = "nickie";
obje.phone = 3393;
//πχ μετά τις παραπάνω αναθέσεις, το obje τώρα είναι το { name: "nickie", phone: 3393 }
console.log(obje);
//αν προσπαθήσω να προσπελάσω μία property που δεν υπάρχει στο object,
//φυσικά θα λάβω την τιμή undefined (και όχι null)
console.log(obje.address);

//Μπορώ επίσης να ορίσω ένα αντικείμενο και να δηλώσω κατευθείαν τις
//ιδιότητές του χωρίς να χρειάζεται να το χτίσω σιγά-σιγά από το κενό object
let objec = { name: "nickie",
            phone: 3393 }

//Μπορώ να αναφερθώ σε μία ιδιότητα είτε έτσι...
objec.name
//...είτε έτσι
objec["name"]

//Παρατηρούμε ότι ο τελευταίος συμβολισμός είναι ο ίδιος συμβολισμός
//που έχει για τα arrays η JavaScript.
//πράγματι, τα arrays είναι απλώς μία ειδική περίπτωση αντικειμένων!

//αν η ιδιότητα που θέλω δεν είναι identifier, δηλαδή το όνομά της δεν είναι μία απλή
//συμβολοσειρά χωρίς κενά, τότε για να την προσπελάσω μπορώ να χρησιμοποιήσω
//ΜΟΝΟ το δευτερο τρόπο
obj[1] // το obj.1 θα πετάξει συντακτικό σφάλμα
obj["last name"] // το obj.last name θα πετάξει συντακτικό σφάλμα

//Έχουμε getters και setters κλάσεων, ακριβώς όπως στη Java
class Person {
    constructor(first, last) {
        this.first = first;
        this.last = last;
    }

    //αυτό είναι ένα getter function: συμπεριφέρεται δηλαδή σαν να είναι μία ιδιότητα
    //με όνομα name και όταν πάω να διαβάσω την τιμή αυτής της "ιδιότητας" καλείται
    //η συνάρτηση μέσα στο σώμα του getter, και ως τιμή της "ιδιότητας" λαμβάνω
    //την τιμή που μου επιστρέφει η συνάρτηση.
    get name() {
        return `${this.first} ${this.last}`;
    }

    //αυτό είναι ένα setter function: χρησιμοποιείται όταν πάμε να αναθέσουμε σε μία
    //"ιδιότητα" με το όνομα του setter.
    set name(n) {
        //Εδώ κάνω μία παρένθεση για έναν πολύ ενδιαφέροντα μηχανισμό της JavaScript:
        //Το destructuring asssignement. Το παρακάτω είναι ένα destructuring assignement!
        //Περισσότερη εξήγηση για αυτό έχουμε πιο κάτω.
        //Εδώ η συνάρτηση split θα σπάσει τη συμβολοσειρά εκεί που θα βρει " "
        //(κενό διάστημα). Το πρώτο κομμάτι συμβολοσειράς που προκύπτει από το σπάσιμο
        //θα το βάλει στο this.first και το δεύτερο στο this.last
        [this.first, this.last] = n.split(" ");
    }
}

let p = new Person("John", "Doe");
console.log(p.name);
p.name = "Michael Cane";
console.log(p.last);

//Inheritance: Παρόμοια με άλλες ΟΟ γλώσσες προγραμματισμού.
class Employee extends Person {
    constructor(first, last, salary) {
        //καλεί τον constructor της super κλάσης, δηλαδή της κλάσης που βρίσκεται 
        //πάνω από αυτήν στην ιεραρχία (εδώ δηλαδή καλεί τον constructor της Person)
        super(first, last);
        this.salary = salary;
    }

    get name() {
        //με το super.name καλεί τη μέθοδο name της super κλάσης, εδώ δηλαδή της
        //κλάσης Person.
        return `${super.name} (${this.salary})`;
    }
}

let e = new Employee("John", "Doe", 1000);
console.log(e.name);

console.log(exampleSeperator)

//==================================================================================================================================

//Arrays
//Μπορούμε να ορίσουμε πίνακες με έναν από τους παρακάτω 3 ισοδύναμους τρόπους:
let a1 = [1, 2, 3, 4]
let a2 = Array(1, 2, 3, 4)
let a3 = new Array(1, 2, 3, 4)

console.log(a1)
console.log(a2)
console.log(a3)

//προσοχή όμως!
//αν χρησιμοποιήσω τους 2 τελευταίους τρόπους με ένα μόνο όρισμα (πχ Array(42) ή new Array(42))
//δεν δημιουργώ ένα πίνακα που έχει μόνο το 42 μέσα, αλλά ένα πίνακα μήκους 42, με όλα τα στοιχεία
//του να είναι undefined (και όχι null). Κι αυτό ίσως να μπορούσε να χαρακτηριστεί το έκτο περίεργο
//της JavaScript, αλλά εδώ λέω να της το συγχωρήσουμε. 
let a4 = Array(42)
let a5 = new Array(42)

console.log(a4)
console.log(a5)

//Η ιδιότητα length των Arrays μου δίνει φυσικά το μέγεθος του πίνακα
//Πχ στον παρακάτω προκύπτει length=4
let a6 = [1, 2, 3, 4]
console.log(a6.length)

//ενώ σε αυτόν length=0
let a7 = []
console.log(a7.length)

//αν γράψω α7[16] πάω να προσπελάσω μία θέση που δεν υπάρχει, μία θέση που είναι μεγαλύτερη
//από το μήκος του πίνακά μου. Και εδώ πραγματικά έρχεται το...
//Έκτο περίεργο της JavaScript:
//Μια τέτοια ανάθεση, δηλαδή σε θέση μεγαλύτερη από το μήκος
//του πίνακα, δεν θα πετάξει error, αλλά αντίθετα θα ΜΕΓΑΛΩΣΕΙ τον πίνακα,
//προσθέτοντας όσα undefined στοιχεία χρειαζεται για να φτάσει την θέση που θέλω να αναθέσω,
//και στην θέση 16 θα μου βάλει το 42. Το νέo length θα είναι 17!
a7[16] = 42
console.log(a7)
console.log(a7[16])
console.log(a7.length)

//Μπορώ επίσης να μεταβάλλω απευθείας το length αναθέτοντάς του μία νέα τιμή
//εδώ αρχικά έχω length=4
let a8 = [1, 2, 3, 4]
console.log(a8.length)

//μπορώ να μικρύνω τον πίνακα, και αν το κάνω τότε τα παραπανίσια στοιχεία θα πεταχτούν
a8.length = 2
console.log(a8)

//μπορώ επίσης να μεγαλώσω τον πίνακα, και αν το κάνω θα προστεθούν όσα undefined στοιχεία
//χρειάζονται για να φτάσει ο πίνακας στο επιθυμητό μέγεθος 
a8.length = 7
console.log(a8)

//iterate through arrays 
//Ο πιο κλασσικός τρόπος:
let a9 = [1, 2, 3, 4]
for (let i = 0; i < a9.length; i++)
    console.log(a9[i]);

//Κι ένας λίγο κομψότερος (που μας λέει ουσιαστικά: επανάλαβε για κλαθε στοιχείο x του πίνακα a9)
for (const x of a9)
    console.log(x);

//Tα Arrays διαθέτουν επίσης τη μέθοδο forEach, η οποία παίρνει ως όρισμα μία συνάρτηση και την
//εφαρμόζει σε όλα τα στοιχεία του πίνακα (εδώ λοιπόν το x είναι ένα στοιχείο του πίνακα).
//Τη συνάρτηση-όρισμα μπορώ να την γράψω είτε ως function:
a9.forEach(function(x) {
            console.log(x);
         });

//είτε ως arrow function
a9.forEach(x => console.log(x));

//Array methods

//προσθήκη ενός στοιχείου στο τέλος ενός array
a9.push(5);
console.log(a9)

//προσθήκη περισσότερων στοιχείων στο τέλος ενός array
let a10 = a9.concat(6, 7)
console.log(a10)

//προσθήκη ολόκληρου πίνακα στο τέλος ενός array
let a11 = a9.concat(a9)
console.log(a11)

//Η join φτιάχνει ένα string με τα στοιχεία του πίνακα χωρισμένα με
//τη συμβολοσειρά που της δίνουμε ως όρισμα
let strin = a9.join(",")
console.log(strin)

let stringy = a9.join(" fun ")
console.log(stringy)

//Η pop επιστρέφει και αφαιρεί το τελευταίο στοιχείο του πίνακα
console.log(a10)
let elem = a10.pop()
console.log(elem)
console.log(a10)

//Η slice μου κόβει μία φέτα του πίνακα από το στοιχείο στο θέση 1 μέχρι το στοιχείο στη θέση 4
//(μέχρι ΚΑΙ τη θέση 3, αλλά όχι το στοιχείο στη θέση 4) 
let a12 = a11.slice(1, 4);
console.log(a11)
console.log(a12)

//H splice θα ξεκινήσει από τη θέση 1 μέχρι KAI το στοιχείο στη θέση 4 και θα πάρει τα 4 στοιχεία,
//θα τα ΒΓΑΛΕΙ από τον πίνακα και θα μου τα επιστρέψει
let a13 = a11.splice(1, 4);
console.log(a11)
console.log(a13)

//Iterators
//Ας ορίσουμε μία συνάρτηση traverse, που διασχίζει έναν iterator
function traverse(it) {
    //Η συνάρτηση traverse αρχικά καλέί τη next μέθοδο του iterator
    //για να πάρει την πρώτη τιμή που γυρνάει ο iterator
    let result = it.next();
    //και στη συνέχεια τυπώνει επαναληπτικά και λαμβάνει την επόμενη
    //τιμή του iterator, μέχρι αυτός να μην έχει άλλες τιμές (να είναι done)
    while (!result.done) {
        console.log(result.value);
        result = it.next();
    }
}

//Ας ορίσουμε επίσης την κλάση Range με τρόπο τέτοιο ώστε να λειτουργεί το range της Python
class Range {
    constructor(lower, upper) {
        this.value = lower;
        this.upper = upper;
    }
    //Η range αποτελεί ουσιαστικά έναν iterator. Κάθε φορά που καλείται η next,
    //υπάρχουν δύο περιπτώσεις:
    //α) να έχουμε εξαντλήσει όλα τα στοιχεία
    //β) να μην έχουμε εξαντλήσει όλα τα στοιχεία
    //Σε κάθε μία από τις δύο περιπτώσεις, θέλουμε η next() να κάνει κάτι διαφορετικό:
    next() {
        //α) αν έχω ακόμα στοιχεία να επιστρέψω:
        if (this.value < this.upper)
            //Με τη next θέλω να επιστρέψω κάτι που έχει τη συμπεριφορά των iterators
            //που περιγράψαμε παραπάνω, δηλαδή να έχει μία ιδιότητα done με τιμή false
            //και μία ιδιότητα value.
            //Θα επιστρέψω λοιπόν ένα καινούργιο αντικείμενο που θα έχει μία ιδιότητα
            //value και μία ιδιότητα done
            return { value: this.value++, done: false }
        //β) αν δεν έχω άλλα στοιχεία να επιστρέψω:
        else
            //με τη next αρκεί να επιστρέψω κάτι που έχει μία ιδιότητα done με τιμή true.
            return { done: true };
    }
}

let r = new Range(0, 9);
traverse(r);

//Δημιουργία ενός generator σαν αυτούς της Python:
//Έχουμε φτιάξει μία συνάρτηση και για να υλοποιήσουμε το iterator pattern χρειαζόμαστε
//ένα είδος αντικειμένου, δηλαδή πρέπει να βάλουμε αυτή τη συνάρτηση μέσα σε ένα αντικείμενο
//όπως κάναμε παραπάνω με την δημιουργία της κλάσης Range. Η JavaScript αυτό μπορεί να το
//κάνει μόνη της. Αυτό γίνεται βάζοντας το * δίπλα από το function. Έτσι ορίζουμε ένα generator
//function. Generator function είναι ένα αντικείμενο ουσιαστικά το οποίο υλοποιεί το iterator
//protocol και το οποίο κάνει το εξής: κάθε φορά που φτάνει σε ένα yield, το yield έχει την επόμενη
//τιμή που θα γυρίσει το next του iterator, δηλαδή είναι σαν να "παγώνει" η εκτέλεση αυτής της
//συνάρτησης τη στιγμή που βρίσκει το yield και να επιστρέφεται η πρώτη τιμή. Αν αργότερα ξαναζητηθεί
//τιμή από το επόμενο next του iterator θα ξαναεκτελεστεί η συνάρτηση και θα παράξει την επόμενη τιμή,
//θα ξαναπαγώσει στο yield κοκ
//Οι generators είναι ειδική περίπτωση iterators
function* rangeGenerator(lower, upper) {
    for (let i = lower; i < upper; i++)
        yield i;
}

let tr = rangeGenerator(0, 10);
traverse(tr)

//Η παρακάτω συνάρτηση generator δεν τερματίζει ποτέ, αφού έχει while true.
//Τί θα γίνει αν την κάνω traverse?
//let fibo = fibonacciGenerator();
//traverse(fibo);
//Αν εκτελέσω τις δύο αυτές εντολές, θα μου τυπώνει fibonacci αριθμούς ατέρμωνα
function* fibonacciGenerator() {
    let a = 0, b = 1;
    yield a; yield b;
    while (true) {
        let c = a + b;
        yield c;
        [a, b] = [b, c];
    }
}

//Με τον παρακάτω τρόπο θα μπορώ να τυπώσει τους πρώτους ν αριθμούς fibonacci
let fibo = fibonacciGenerator();
let n = 20
for (let i=0; i < n; i++)
    console.log(fibo.next().value)

//Iterables ή αλλιώς Iterable Objects
/*Τα iterables μπορώ να τα χρησιμοποιήσω σε loops με τη λέξη of
Αν γράψω το παρακάτω:

let a = new Range(0, 10);
for (const x of a)
    console.log(x);

Η JavaScript θα πετάξει σφάλμα λέγοντας μου ότι το a δεν είναι iterable. Αυτό συμβαίνει διότι το a είναι αντικείμενο της
κλάσης Range, η οποία όπως την ορίσαμε δεν έχει μέθοδο [Symbol.iterator].
Ας την συμπληρώσουμε:
*/

class iterableRange {
    constructor(lower, upper) {
        this.value = lower;
        this.upper = upper;
    }

    [Symbol.iterator] () {
        return this;
    }

    next() {
        if (this.value < this.upper)
            return { value: this.value++, done: false }
        else
            return { done: true };
    }
}

let ran = new iterableRange(0, 10);
for (const x of ran)
    console.log(x);

//Οι generator functions που μου δίνει η Javascript όταν βάζω *, είναι iterables:
let rangen = rangeGenerator(0, 10);
for (const x of rangen)
    console.log(x);

console.log(exampleSeperator)

//==================================================================================================================================

//Destructuring assignements
//Πολύ χρήσιμος μηχανισμός, θα τον χρησιμοποιείτε συνέχεια
//Κάτι παρόμοιο υπάρχει και στην Python, όμως υπάρχουν διαφορές μεταξύ των δύο γλωσσών
let [alpha, beta] = [42, 17]; //alpha=42, beta=17
console.log([alpha, beta]);

[alpha, beta] = [beta, alpha]; //αντιμετάθεση των τιμών alpha και beta. Η ανάθεση γίνεται ΣΥΓΧΡΟΝΩΣ και όχι με τη σειρά
console.log([alpha, beta]);

[alpha, beta] = [42]; //alpha = 42, beta = undefined
console.log([alpha, beta]);

//Το παρακάτω πιθανώς να θυμίσει το pattern matching της ML
let [first, ...rest] = [17, 42, 1, 2, 3]; //first = 17, rest = [42, 1, 2, 3]
console.log(first);
console.log(rest);

//Μάλιστα, το destructuring asssignement δεν δουλεύει μόνο με arrays, αλλά με όλα τα iterables!

//Αυτή η γραμμή μας λέει: φτιάξε 4 μεταβλητές και αρχικοποίησε της τιμές τους τραβώντας τιμές  από τον fibonacci generator
let [u, v, w, ze] = fibonacciGenerator();
console.log([u, v, w, ze]);

//Δουλεύει επίσης με αντικείμενα (η χρήση του με αντικείμενα είναι πολύ συχνή)
let per = { name: "nickie", phone: 3393 };
let {name, phone} = per; //name = "nickie", phone = 3393
console.log(name)
console.log(phone)

//Το επόμενο ορίζει 2 μεταβλητές myName και myPhone, που οι τιμές τους είναι οι τιμές που έχει το name και to phone μέσα
//στο αντικείμενο per
let {name: myName, phone: myPhone} = per; //myName = per.name, myPhone = per.phone
console.log(myName);
console.log(myPhone);

//έχουμε και rest notation μέσα σε αντικείμενα. Εδώ (στην περίπτωση του αντικειμένου δηλαδή) το vRest δεν είναι λίστα αλλά ένα αντικείμενο
//που έχει όλα τα υπόλοιπα πεδία που δεν έχουμε βάλει, δηλαδή εδώ το c και το d
let antikeimeno = { a: 1, b: 2, c: 3, d: 4 };
//η παράμετρος x έχει μεταβλητή vX και default τιμή 42
//vA = antikeimeno.a, vB = antikeimeno.b, vRest = { c: 3, d: 4}
let {a: vA, b: vB, x: vX = 42, ...vRest} = antikeimeno;
console.log(vA);
console.log(vB);
console.log(vX);
console.log(vRest);

//Spread operator
//Είναι ουσιαστικά το ανάποδο από το destructuring
//Έστω ότι έχω μία συνάρτηση f που παίρνει κάποιες παραμέτρους και εγώ θέλω να την καλέσω δίνοντας μία λίστα που έχει όλες αυτές
//τις παραμέτρους μέσα. Αυτό μπορώ να το κάνω με ένα annotation παρόμοιο του ...rest, το ...args, το οποίο λέγεται spread
//operator.
function f(a, b) {
    console.log(a*b);
}

let args = [6, 7]
f(...args)

console.log(exampleSeperator)

//==================================================================================================================================

//Asynchronous programming
//Ό,τι έχουμε δει μέχρι στιγμής αφορούσε πράγματα που γίνονται σύγχρονα
//Η JavaScript όμως μας δίνει τη δυνατότητα να εκτελέσουμε εντολές ασύγχρονα.
//Με απλά λόγια, ο ασύγχρονος προγραμματισμός είναι ένα είδος παράλληλου
//προγραμματισμού, που επιτρέπει σε μία εργασία να εκτελείται ανεξάρτητα
//από μία άλλη, ή από την κύρια εφαρμογή. Όταν η εργασία αυτή ολοκληρωθεί
//(ή αν αποτύχει λόγω σφάλματος), ειδοποιεί την κύρια εργασία. Κάτι τέτοιο
//έχει πολλά πλεονεκτήματα, όπως βελτίωση της απόδοσης της εφαρμογής και 
//καλύτερη απόκριση. Φυσικά πρέπει να χρησιμοποιείται εκεί που χρειάζεται
//κι όχι παντού.

//Η figlet είναι μια βιβλιοθήκη που δημιουργεί πανό κειμένου
const figlet = require('figlet');

figlet('Hello World!!', (err, data) => console.log(data));

//Promises
//Ο πρώτος τρόπος για να γράψουμε ασύγχρονο κώδικα είναι με Promises
const fetch = require('node-fetch');

function getTime(url) {
    //H fetch χτυπάει url και επιστρέφει ένα Promise. Όταν το Promise εκπληρωθεί,
    //δηλαδή όταν η fetch λάβει μία απάντηση από το url, τότε το Promise επιστρέφει την
    //απάντηση αυτή ως αποτέλεσμα
    const promise = fetch(url);
    //console.log(promise);

    //Η μέθοδος then ενός Promise παίρνει δύο ορίσματα,
    //έναν success handler και έναν error handler. Οι handlers αυτοί
    //καλούνται callbacks functions, και καλούνται μόνο μία φορά,
    //όταν ολοκληρωθεί η αποτύχει η ασύγχρονη εργασία που περιμένει το Promise.
    //Η then επιστρέφει επίσης ένα Promise. Με αυτό τον τρόπο μπορούμε να δημιουργήσουμε
    //αλυσίδες από Promises, δηλαδή από actions που η κάθεμια περιμένει την προηγούμενη
    //να ολοκληρωθεί πριν εκτελεστεί. Οι handlers μπορούν να επιστρέφουν κάποια τιμή,
    //η οποία θα περαστεί στο handler του επόμενου then της αλυσίδας.
    //Στην παρακάτω αλυσίδα, αρχικά χτυπάμε το url και μόλις λάβει η fetch μία απάντηση,
    //την data, τότε μετατρέπουμε αυτή την απάντηση σε JSON. Όταν η μετατροπή ολοκληρωθεί
    //θα μας επιστρέψει μία τιμή data (που είναι το json). Από αυτό το αντικείμενο εμείς θέλουμε την ιδιότητα
    //datetime. Τέλος, λαμβάνοντας την datetime (ως data) την τυπώνουμε. Παράλληλα έχουμε βάλει και
    //τη μέθοδο catch, η οποία θα πιάσει οποιοδήποτε σφάλμα err, και εδώ απλώς θα τυπώσει never mind.
    return fetch(url)
        .then(data => data.json())
        .then(data => data['datetime'])
        .then(data => console.log(data))
        .catch(err => console.log("never mind"));
}

getTime('http://worldtimeapi.org/api/timezone/Europe/Athens');
//Παρατηρούμε ότι αν βάλουμε την παρακάτω γραμμή, τα δύο getTime δεν γίνονται σύγχρονα, δηλαδή δεν εκτελούνται
//απαραίτητα με τη σειρά που τα βάλαμε. Τις περισσότερες φορές που το εκτελούμε,
//τελειώνει πρώτο το wrong.url και όλο το πρόγραμμα σταματάει, χωρίς να τυπωθεί η ημερομηνία που μας δίνει το API
//getTime('http://wrong.url');
//Αυτό είναι και το νόημα των ασύγχρονων actions, να εκτελούνται ανεξάρτητα η μία από την άλλη,
//χωρίς να περιμένει η μία να τελειώσει η άλλη.

//Async-await
//Ο δεύτερος τρόπος για να γράψουμε ασύγχρονο κώδικα είναι με το ζευγάρι λέξεων κλειδιών async-await.
//Αυτός είναι και ο προτιμότερος τρόπος πλέον.
//Ας δημιουργήσουμε αρχικά μία συνάρτηση που φτιάχνει ένα promise
function getTimeAlt(url) {
    return fetch(url)
        .then(data => data.json())
        .then(data => data['datetime'])
        .catch(err =>"never mind");
}

//και τώρα ας ορίσουμε μία ασύγχρονη συνάρτηση με τη λέξη κλειδί async.
async function main() {
    //καλούμε τη συνάρτηση getTimeAlt που επιστρέφει promise μέσα στη main και παίρνουμε το promise της
    const promise = getTimeAlt('http://worldtimeapi.org/api/timezone/Europe/Athens')
    //Με τη λέξη await μπορούμε να περιμένουμε το αποτέλεσμά της, σαν να ήταν σύγχρονη.
    //Αυτό σημαίνει ότι εκεί που θα μπει η λέξη await παγώνει η εκτέλεση της συνάρτησης main μέχρι
    //να εκπληρωθεί το promise το οποίο κάνυμε await. Η λέξη await μπορεί να χρησιμοποιηθεί μόνο μέσα σε
    //συναρτήσεις που έχουν μπροστά τη λέξη async, αλλιώς προκύπτει συντακτικό σφάλμα. 
    //το t θα είναι η απάντηση του τελευταίου then, στην προκειμένη περίπτωση το datetime δηλαδή
    const t = await promise
    console.log(t);
}

main()

//Ουσιαστικά λοιπόν εμείς φτιάχνουμε μία ασύγχρονη συνάρτηση, η οποία κάποια στιγμή θα περιμένει ένα (ή όσα θέλουμε) promise.
//Όσο αυτή περιμένει αυτό το promise παγώνοντας την εκτέλεσή της εκεί, άλλα πράγματα τα οποία επίσης είναι ασύγχρονα μπορούν να
//συνεχίσουν να εκτελούνται. Με άλλα λόγια, με το await γίνεται suspend αυτό το ασύγχρονο νήμα όσο εκτελούνται άλλα
//ασύγχρονα νήματα κι έτσι έχουμε παραλληλοποίηση.

async function mainsecond() {
    let right = getTimeAlt('http://worldtimeapi.org/api/timezone/Europe/Athens');
    let wrong = getTimeAlt('http://wrong.url');

    //Με αυτό τον τρόπο δεν είναι απαραίτητο ότι το right θα υπολογιστεί πριν από το wrong,
    //όμως είναι σίγουρο ότι το right θα τυπωθεί πριν από το wrong, διότι έχουμε κάνει await στην εκτύπωση
    //και των δύο, και το πρώτο await περιμένει τη right. 
    //Το να κάνουμε τον υπολογισμό αυτών των δύο να είναι ασύγχρονος αλλά η εκτύπωσή τους να είναι σύγχρονη θα ήταν δύσκολο
    //να γίνει αν χρησιμοποιούσαμε μόνο promises, χωρίς async functions. Οι async functions λοιπόν μας επιτρέπουν και τέτοια κόλπα.
    console.log(await right);
    console.log(await wrong);
}

mainsecond();
